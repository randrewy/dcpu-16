#include "LEM1802.h"

enum{
   HARDVAREID = 0x7349f615,
   HARDWATREVERSION = 0x1802,
   MANUFACTURERID = 0x1c6c8b36
};

enum{
   MEM_MAP_SCREEN    =0,  // Reads the B register, and maps the video RAM to DCPU-16 RAM starting at address B.
                          // See below for a description of video RAM. If B is 0, the screen is disconnected.
                          // When the screen goes from 0 to any other value, the the LEM1802 takes about one
                          // second to start up. Other interrupts sent during this time are still processed.
 	MEM_MAP_FONT      =1,  // Reads the B register, and maps the font RAM to DCPU-16 RAM starting at address B.
                          // If B is 0, the default font is used instead.
 	MEM_MAP_PALETTE   =2,  // Reads the B register, and maps the color palette RAM to DCPU-16 RAM starting at address B.
                          // If B is 0, the default color palette is used instead.
 	SET_BORDER_COLOR  =3,  // Reads the B register, and sets the border color to palette index B&0xF
 	MEM_DUMP_FONT     =4,  // Reads the B register, and writes the default font data to DCPU-16 RAM starting at address B.
                          // Halts the DCPU-16 for 256 cycles
 	MEM_DUMP_PALETTE  =5   // Reads the B register, and writes the default color palette data to DCPU-16 RAM starting at
                          // address B. Halts the DCPU-16 for 16 cycles 
};

enum{
   RAM_SIZE = 384,
   PALETTE_SIZE = 16,
   FONT_SIZE = 256
};

extern const DCPU::Word Default_Palette[];
extern const DCPU::Word Default_Font_v1[];
extern const DCPU::Word Default_Font_v2[];
extern const DCPU::Word* Default_Font = Default_Font_v1;


namespace DCPU{
using namespace LEM;
 
   Byte getCharacter (Word w)
   {                          
      return w & 0x7f;        //  0 0 0 0|0 0 0 0|0|1 1 1 1 1 1 1
   }                          //         |       | |
   bool getBlink (Word w)     //         |       | |
   {                          //         |       | |
      return (w>>7) & 0x1;    //  0 0 0 0|0 0 0 0|1|0 0 0 0 0 0 0
   }                          //         |       | |
   Byte getBackground (Word w)//         |       | |
   {                          //         |       | |
      return (w>>8) & 0xF;    //  0 0 0 0|1 1 1 1|0|0 0 0 0 0 0 0 
   }                          //         |       | |
   Byte getForeground (Word w)//         |       | |
   {                          //         |       | |
      return (w>>12)  & 0xF;  //  1 1 1 1|0 0 0 0|0|0 0 0 0 0 0 0
   }

   Color::Color(Word w)
   {
      u = 0;
      b = w & 0xF;
      g = (w>>4) & 0xF;
      r = (w>>8) & 0xF;
   }

   Color Cell::getPixelColor(int i, int j)
   {
      /* F letter:
             Column 	   Word 	  Bits
      Y<-------------------------------------
         |   01111111 	0       8-15
         |   00001001 	0       0-7
         |   00000001 	1       8-15
        X|   00000000 	1       0-7
      */
      Byte t;
      switch(j)
      {
         case 0: t = getHigh8(w1); break;
         case 1: t = getLow8 (w1); break;
         case 2: t = getHigh8(w2); break;
         case 3: t = getLow8 (w2); break;
         default :throw;
      }
      if(i<8)
         return ((t>>i) & 0x1)  ?  f : b;
      throw;
   }

   LEM1802::LEM1802() : border_color(0)
   {
      screen_ram = 0;
      font_ram = Default_Font;
      palette_ram = Default_Palette;
   }

   Cell LEM1802::getCell(Word row, Word col)const
   {
      if(!screen_ram) throw LEM1802::Screen_Mem_Error();
      Cell C;
      Word cw = screen_ram[row*DISPLAY_WIDTH_CELL + col];
      C.b = palette_ram[getBackground(cw)];
      C.f = palette_ram[getForeground(cw)];
      C.blink = getBlink(cw);
      C.w1 = font_ram[2*getCharacter(cw)];
      C.w2 = font_ram[2*getCharacter(cw) + 1];

      return C;
   }

   bool LEM1802::connected()const
   {
      return screen_ram !=0;        // dear compiler, I want this
   }

   HWInfo LEM1802::info(){ 
      return HWInfo(HARDVAREID, HARDWATREVERSION, MANUFACTURERID);
   }

   Word LEM1802::interrupt()
   {
      switch(reg[Codes::A])
      {
         case MEM_MAP_SCREEN:
            if(reg[Codes::B])
               screen_ram = &mem->at(reg[Codes::B]);
            else screen_ram = 0;
            return 0;

         case MEM_MAP_FONT:
            if(reg[Codes::B])
               font_ram = &mem->at(reg[Codes::B]);
            else font_ram = Default_Font;
            return 0;

         case MEM_MAP_PALETTE:
            if(reg[Codes::B])
               palette_ram = &mem->at(reg[Codes::B]);
            else palette_ram = Default_Palette;
            return 0;

         case SET_BORDER_COLOR:
            border_color = reg[Codes::B] & 0xF;
            return 0;

         case MEM_DUMP_FONT:
            for(int i = 0; i<FONT_SIZE; i++)
               mem->at(reg[Codes::B+i]) = Default_Font[i];
            return FONT_SIZE;

         case MEM_DUMP_PALETTE:
            for(int i = 0; i<PALETTE_SIZE; i++)
               mem->at(reg[Codes::B+i]) = Default_Palette[i];
            return PALETTE_SIZE;
         default:
            throw;
      }
   }

   void LEM1802::connect(Memory* m, Word* r, Word&, Word&, Word&)
   {
      reg = r;
      mem = m;
      screen_ram = &mem->at(VRAM_ADSRESS_ASSUMPTION);
   }

}


const DCPU::Word Default_Palette[] = {
   0x0000,      0x000a,	 	  0x00a0,	  0x00aa,
   0x0a00,      0x0a0a,	 	  0x0a50,	  0x0aaa,
   0x0555, 	    0x055f, 	  0x05f5, 	  0x05ff, 	  
   0x0f55,	    0x0f5f, 	  0x0ff5, 	  0x0fff	  
};

const DCPU::Word Default_Font_v1[] = {
   0x000f, 0x0808, 0x080f, 0x0808, 0x08f8, 0x0808, 0x00ff, 0x0808, 
   0x0808, 0x0808, 0x08ff, 0x0808, 0x00ff, 0x1414, 0xff00, 0xff08,
   0x1f10, 0x1714, 0xfc04, 0xf414, 0x1710, 0x1714, 0xf404, 0xf414,
   0xff00, 0xf714, 0x1414, 0x1414, 0xf700, 0xf714, 0x1417, 0x1414,
   0x0f08, 0x0f08, 0x14f4, 0x1414, 0xf808, 0xf808, 0x0f08, 0x0f08,
   0x001f, 0x1414, 0x00fc, 0x1414, 0xf808, 0xf808, 0xff08, 0xff08,
   0x14ff, 0x1414, 0x080f, 0x0000, 0x00f8, 0x0808, 0xffff, 0xffff, 
   0xf0f0, 0xf0f0, 0xffff, 0x0000, 0x0000, 0xffff, 0x0f0f, 0x0f0f, 
   0x0000, 0x0000, 0x005f, 0x0000, 0x0300, 0x0300, 0x3e14, 0x3e00, 
   0x266b, 0x3200, 0x611c, 0x4300, 0x3629, 0x7650, 0x0002, 0x0100, 
   0x1c22, 0x4100, 0x4122, 0x1c00, 0x2a1c, 0x2a00, 0x083e, 0x0800, 
   0x4020, 0x0000, 0x0808, 0x0800, 0x0040, 0x0000, 0x601c, 0x0300, 
   0x3e41, 0x3e00, 0x427f, 0x4000, 0x6259, 0x4600, 0x2249, 0x3600, 
   0x0f08, 0x7f00, 0x2745, 0x3900, 0x3e49, 0x3200, 0x6119, 0x0700, 
   0x3649, 0x3600, 0x2649, 0x3e00, 0x0024, 0x0000, 0x4024, 0x0000, 
   0x0814, 0x2241, 0x1414, 0x1400, 0x4122, 0x1408, 0x0259, 0x0600, 
   0x3e59, 0x5e00, 0x7e09, 0x7e00, 0x7f49, 0x3600, 0x3e41, 0x2200, 
   0x7f41, 0x3e00, 0x7f49, 0x4100, 0x7f09, 0x0100, 0x3e49, 0x3a00, 
   0x7f08, 0x7f00, 0x417f, 0x4100, 0x2040, 0x3f00, 0x7f0c, 0x7300, 
   0x7f40, 0x4000, 0x7f06, 0x7f00, 0x7f01, 0x7e00, 0x3e41, 0x3e00, 
   0x7f09, 0x0600, 0x3e41, 0xbe00, 0x7f09, 0x7600, 0x2649, 0x3200, 
   0x017f, 0x0100, 0x7f40, 0x7f00, 0x1f60, 0x1f00, 0x7f30, 0x7f00, 
   0x7708, 0x7700, 0x0778, 0x0700, 0x7149, 0x4700, 0x007f, 0x4100, 
   0x031c, 0x6000, 0x0041, 0x7f00, 0x0201, 0x0200, 0x8080, 0x8000, 
   0x0001, 0x0200, 0x2454, 0x7800, 0x7f44, 0x3800, 0x3844, 0x2800, 
   0x3844, 0x7f00, 0x3854, 0x5800, 0x087e, 0x0900, 0x4854, 0x3c00, 
   0x7f04, 0x7800, 0x447d, 0x4000, 0x2040, 0x3d00, 0x7f10, 0x6c00, 
   0x417f, 0x4000, 0x7c18, 0x7c00, 0x7c04, 0x7800, 0x3844, 0x3800, 
   0x7c14, 0x0800, 0x0814, 0x7c00, 0x7c04, 0x0800, 0x4854, 0x2400, 
   0x043e, 0x4400, 0x3c40, 0x7c00, 0x1c60, 0x1c00, 0x7c30, 0x7c00, 
   0x6c10, 0x6c00, 0x4c50, 0x3c00, 0x6454, 0x4c00, 0x0836, 0x4100, 
   0x0077, 0x0000, 0x4136, 0x0800, 0x0201, 0x0201, 0x704c, 0x7000
};



const DCPU::Word Default_Font_v2[] = {
   0xb79e, 0x388e, 0x722c, 0x75f4, 0x19bb, 0x7f8f, 0x85f9, 0xb158,
   0x242e, 0x2400, 0x082a, 0x0800, 0x0008, 0x0000, 0x0808, 0x0808,
   0x00ff, 0x0000, 0x00f8, 0x0808, 0x08f8, 0x0000, 0x080f, 0x0000,
   0x000f, 0x0808, 0x00ff, 0x0808, 0x08f8, 0x0808, 0x08ff, 0x0000,
   0x080f, 0x0808, 0x08ff, 0x0808, 0x6633, 0x99cc, 0x9933, 0x66cc,
   0xfef8, 0xe080, 0x7f1f, 0x0701, 0x0107, 0x1f7f, 0x80e0, 0xf8fe,
   0x5500, 0xaa00, 0x55aa, 0x55aa, 0xffaa, 0xff55, 0x0f0f, 0x0f0f,
   0xf0f0, 0xf0f0, 0x0000, 0xffff, 0xffff, 0x0000, 0xffff, 0xffff,
   0x0000, 0x0000, 0x005f, 0x0000, 0x0300, 0x0300, 0x3e14, 0x3e00,
   0x266b, 0x3200, 0x611c, 0x4300, 0x3629, 0x7650, 0x0002, 0x0100,
   0x1c22, 0x4100, 0x4122, 0x1c00, 0x1408, 0x1400, 0x081c, 0x0800,
   0x4020, 0x0000, 0x0808, 0x0800, 0x0040, 0x0000, 0x601c, 0x0300,
   0x3e49, 0x3e00, 0x427f, 0x4000, 0x6259, 0x4600, 0x2249, 0x3600,
   0x0f08, 0x7f00, 0x2745, 0x3900, 0x3e49, 0x3200, 0x6119, 0x0700,
   0x3649, 0x3600, 0x2649, 0x3e00, 0x0024, 0x0000, 0x4024, 0x0000,
   0x0814, 0x2200, 0x1414, 0x1400, 0x2214, 0x0800, 0x0259, 0x0600,
   0x3e59, 0x5e00, 0x7e09, 0x7e00, 0x7f49, 0x3600, 0x3e41, 0x2200,
   0x7f41, 0x3e00, 0x7f49, 0x4100, 0x7f09, 0x0100, 0x3e41, 0x7a00,
   0x7f08, 0x7f00, 0x417f, 0x4100, 0x2040, 0x3f00, 0x7f08, 0x7700,
   0x7f40, 0x4000, 0x7f06, 0x7f00, 0x7f01, 0x7e00, 0x3e41, 0x3e00,
   0x7f09, 0x0600, 0x3e61, 0x7e00, 0x7f09, 0x7600, 0x2649, 0x3200,
   0x017f, 0x0100, 0x3f40, 0x7f00, 0x1f60, 0x1f00, 0x7f30, 0x7f00,
   0x7708, 0x7700, 0x0778, 0x0700, 0x7149, 0x4700, 0x007f, 0x4100,
   0x031c, 0x6000, 0x417f, 0x0000, 0x0201, 0x0200, 0x8080, 0x8000,
   0x0001, 0x0200, 0x2454, 0x7800, 0x7f44, 0x3800, 0x3844, 0x2800,
   0x3844, 0x7f00, 0x3854, 0x5800, 0x087e, 0x0900, 0x4854, 0x3c00,
   0x7f04, 0x7800, 0x047d, 0x0000, 0x2040, 0x3d00, 0x7f10, 0x6c00,
   0x017f, 0x0000, 0x7c18, 0x7c00, 0x7c04, 0x7800, 0x3844, 0x3800,
   0x7c14, 0x0800, 0x0814, 0x7c00, 0x7c04, 0x0800, 0x4854, 0x2400,
   0x043e, 0x4400, 0x3c40, 0x7c00, 0x1c60, 0x1c00, 0x7c30, 0x7c00,
   0x6c10, 0x6c00, 0x4c50, 0x3c00, 0x6454, 0x4c00, 0x0836, 0x4100,
   0x0077, 0x0000, 0x4136, 0x0800, 0x0201, 0x0201, 0x0205, 0x0200
};
